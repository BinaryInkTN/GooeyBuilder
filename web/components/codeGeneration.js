import state from "./state.js";
import { getWidgetsInContainer, getWidgetsInTab } from "./hierarchyManager.js";

export async function generateC() {
    let cCode = `/*
 * Generated by GBuilder
 * Application: ${state.projectSettings.name || "Untitled"}
 * Platform: ${state.projectSettings.platform}
 * Date: ${new Date().toLocaleString()}
 */

`;

    if (state.projectSettings.platform === "embedded") {
        cCode += `#include <gooey.h>
#include <Arduino.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

`;
    } else {
        cCode += `#include <Gooey/gooey.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

`;
    }

    const allWidgets = Array.from(
        state.previewContent.querySelectorAll(".widget"),
    );

    const widgetsByType = {
        buttons: [],
        textboxs: [],
        sliders: [],
        checkboxes: [],
        labels: [],
        canvases: [],
        images: [],
        dropsurfaces: [],
        dropdowns: [],
        lists: [],
        progressbars: [],
        meters: [],
        switches: [],
        containers: [],
        tabs: [],
        plots: [],
        radiobuttongroups: [],
    };

    allWidgets.forEach((widget, index) => {
        const type = widget.dataset.type.toLowerCase();
        const cType =
            type === "input"
                ? "textbox"
                : type === "gswitch"
                  ? "switch"
                  : type === "radiobuttongroup"
                    ? "radiobuttongroup"
                    : type;
        const arrayName = cType + "s";

        if (widgetsByType[arrayName]) {
            widgetsByType[arrayName].push({
                widget: widget,
                id: widget.dataset.id,
                type: widget.dataset.type,
                index: widgetsByType[arrayName].length,
                varName:
                    widget.dataset.widgetVar ||
                    `${cType}_${widgetsByType[arrayName].length}`,
                macroName: state.widgetMacroNames.get(widget.dataset.id),
            });
        }
    });

    cCode += `/******************************************************************************
 *                              DEFINES
 ******************************************************************************/

/* Widget index macros */
`;

    Object.entries(widgetsByType).forEach(([arrayName, widgets]) => {
        if (widgets.length > 0) {
            const widgetType = arrayName.replace("s", "").toUpperCase();
            cCode += `/* ${widgetType} indices */\n`;
            widgets.forEach((widgetData, index) => {
                const macroName =
                    widgetData.macroName || `${widgetType}_${index}`;
                cCode += `#define ${macroName.padEnd(40)} (${index}U)\n`;
            });
            cCode += `\n`;
        }
    });

    cCode += `/******************************************************************************
 *                              TYPEDEFS
 ******************************************************************************/

/* Application state structure */
typedef struct
{
    GooeyWindow *window;
    GooeyMenu *menu;
`;

    const usedWidgetTypes = new Set();
    allWidgets.forEach((widget) => usedWidgetTypes.add(widget.dataset.type));

    if (usedWidgetTypes.has("Button")) cCode += `    GooeyButton **buttons;\n`;
    if (usedWidgetTypes.has("Input")) cCode += `    GooeyTextbox **textboxs;\n`;
    if (usedWidgetTypes.has("Slider")) cCode += `    GooeySlider **sliders;\n`;
    if (usedWidgetTypes.has("Checkbox"))
        cCode += `    GooeyCheckbox **checkboxes;\n`;
    if (usedWidgetTypes.has("Label")) cCode += `    GooeyLabel **labels;\n`;
    if (usedWidgetTypes.has("Canvas")) cCode += `    GooeyCanvas **canvases;\n`;
    if (usedWidgetTypes.has("Image")) cCode += `    GooeyImage **images;\n`;
    if (usedWidgetTypes.has("DropSurface"))
        cCode += `    GooeyDropSurface **dropsurfaces;\n`;
    if (usedWidgetTypes.has("Dropdown"))
        cCode += `    GooeyDropdown **dropdowns;\n`;
    if (usedWidgetTypes.has("List")) cCode += `    GooeyList **lists;\n`;
    if (usedWidgetTypes.has("Progressbar"))
        cCode += `    GooeyProgressBar **progressbars;\n`;
    if (usedWidgetTypes.has("Meter")) cCode += `    GooeyMeter **meters;\n`;
    if (usedWidgetTypes.has("GSwitch"))
        cCode += `    GooeySwitch **gswitchs;\n`;
    if (usedWidgetTypes.has("Container"))
        cCode += `    GooeyContainer **containers;\n`;
    if (usedWidgetTypes.has("Tabs")) cCode += `    GooeyTabs **tabs;\n`;
    if (usedWidgetTypes.has("Plot")) cCode += `    GooeyPlot **plots;\n`;
    if (usedWidgetTypes.has("RadioButtonGroup"))
        cCode += `    GooeyRadioButtonGroup **radiobuttongroups;\n`;

    cCode += `    uint32_t button_count;
    uint32_t textbox_count;
    uint32_t slider_count;
    uint32_t checkbox_count;
    uint32_t label_count;
    uint32_t canvas_count;
    uint32_t image_count;
    uint32_t dropsurface_count;
    uint32_t dropdown_count;
    uint32_t list_count;
    uint32_t progressbar_count;
    uint32_t meter_count;
    uint32_t gswitch_count;
    uint32_t container_count;
    uint32_t tabs_count;
    uint32_t plot_count;
    uint32_t radiobuttongroup_count;
    void *user_data;
} AppState;

`;

    const callbacks = [];

    Object.entries(state.widgetCallbacks).forEach(
        ([widgetId, callbackData]) => {
            const widget = document.querySelector(
                `.widget[data-id="${widgetId}"]`,
            );
            if (!widget || !callbackData.callbackName) return;

            const callbackName = callbackData.callbackName;
            const macroName = state.widgetMacroNames.get(widgetId);
            const defaultMacro = `${widget.dataset.type.toLowerCase() === "input" ? "textbox" : widget.dataset.type.toLowerCase()}_0`;

            Object.entries(callbackData).forEach(([type, code]) => {
                if (type.endsWith("_code") && code && code.trim()) {
                    const lines = code.split("\n");
                    if (lines.length > 0) {
                        const firstLine = lines[0].trim();
                        if (
                            firstLine.startsWith("void ") &&
                            firstLine.includes("(")
                        ) {
                            const funcName = firstLine
                                .substring(5, firstLine.indexOf("("))
                                .trim();

                            callbacks.push({
                                funcName: funcName,
                                callbackName: callbackName,
                                code: code,
                                widgetType: widget.dataset.type,
                                widgetId: widgetId,
                                macroName: macroName || defaultMacro,
                            });

                            let wrapperSignature = "";
                            let callbackSignature = "";

                            switch (widget.dataset.type) {
                                case "Slider":
                                    wrapperSignature = `static void ${callbackName}_wrapper(long value, void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state, long value);\n`;
                                    break;
                                case "Checkbox":
                                    wrapperSignature = `static void ${callbackName}_wrapper(bool checked, void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state, bool checked);\n`;
                                    break;
                                case "Input":
                                    wrapperSignature = `static void ${callbackName}_wrapper(char* text, void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state, char* text);\n`;
                                    break;
                                case "Dropdown":
                                case "List":
                                    wrapperSignature = `static void ${callbackName}_wrapper(int selected_index, void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state, int selected_index);\n`;
                                    break;
                                case "GSwitch":
                                    wrapperSignature = `static void ${callbackName}_wrapper(bool toggled, void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state, bool toggled);\n`;
                                    break;
                                case "Image":
                                    wrapperSignature = `static void ${callbackName}_wrapper(void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state);\n`;
                                    break;
                                case "DropSurface":
                                    wrapperSignature = `static void ${callbackName}_wrapper(const char* file_path, void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state, const char* file_path);\n`;
                                    break;
                                case "Tabs":
                                    wrapperSignature = `static void ${callbackName}_wrapper(int tab_index, void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state, int tab_index);\n`;
                                    break;
                                case "Container":
                                    wrapperSignature = `static void ${callbackName}_wrapper(int container_index, void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state, int container_index);\n`;
                                    break;
                                default:
                                    wrapperSignature = `static void ${callbackName}_wrapper(void* user_pointer);\n`;
                                    callbackSignature = `void ${funcName}(AppState* state);\n`;
                            }

                            if (!cCode.includes(wrapperSignature))
                                cCode += wrapperSignature;
                            if (!cCode.includes(callbackSignature))
                                cCode += callbackSignature;
                        }
                    }
                }
            });
        },
    );

    cCode += `
/******************************************************************************
 *                         PRIVATE FUNCTIONS
 ******************************************************************************/
`;

    callbacks.forEach(
        ({ funcName, callbackName, code, widgetType, widgetId, macroName }) => {
            cCode += `
static void ${callbackName}_wrapper(`;

            switch (widgetType) {
                case "Slider":
                    cCode += `long value, void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state, value);
}
`;
                    break;
                case "Checkbox":
                    cCode += `bool checked, void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state, checked);
}
`;
                    break;
                case "Input":
                    cCode += `char* text, void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state, text);
}
`;
                    break;
                case "Dropdown":
                case "List":
                    cCode += `int selected_index, void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state, selected_index);
}
`;
                    break;
                case "GSwitch":
                    cCode += `bool toggled, void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state, toggled);
}
`;
                    break;
                case "Image":
                    cCode += `void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state);
}
`;
                    break;
                case "DropSurface":
                    cCode += `const char* file_path, void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state, file_path);
}
`;
                    break;
                case "Tabs":
                    cCode += `int tab_index, void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state, tab_index);
}
`;
                    break;
                case "Container":
                    cCode += `int container_index, void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state, container_index);
}
`;
                    break;
                default:
                    cCode += `void* user_pointer)
{
    AppState* state = (AppState*)user_pointer;
    ${funcName}(state);
}
`;
            }
        },
    );

    cCode += `
/******************************************************************************
 *                         PUBLIC FUNCTIONS
 ******************************************************************************/
`;

    callbacks.forEach(
        ({ funcName, callbackName, code, widgetType, macroName }) => {
            let updatedCode = code;

            switch (widgetType) {
                case "Slider":
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state, long value)`,
                    );
                    break;
                case "Checkbox":
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state, bool checked)`,
                    );
                    break;
                case "Input":
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state, char* text)`,
                    );
                    break;
                case "Dropdown":
                case "List":
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state, int selected_index)`,
                    );
                    break;
                case "GSwitch":
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state, bool toggled)`,
                    );
                    break;
                case "Image":
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state)`,
                    );
                    break;
                case "DropSurface":
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state, const char* file_path)`,
                    );
                    break;
                case "Tabs":
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state, int tab_index)`,
                    );
                    break;
                case "Container":
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state, int container_index)`,
                    );
                    break;
                default:
                    updatedCode = code.replace(
                        `void ${funcName}(void* user_data)`,
                        `void ${funcName}(AppState* state)`,
                    );
            }

            cCode += updatedCode + "\n\n";
        },
    );

    switch (state.projectSettings.platform) {
        case "embedded":
            cCode += `/******************************************************************************
 *                         ARDUINO SETUP FUNCTION
 ******************************************************************************/

void setup(void)
`;
            break;
        case "desktop":
            cCode += `/******************************************************************************
 *                         MAIN FUNCTION
 ******************************************************************************/

int main(void)
`;
            break;
        default:
            cCode += `int main(void)\n`;
            break;
    }

    cCode += `{
    AppState state = {0};

`;

    const widgetCounts = {
        button: 0,
        textbox: 0,
        slider: 0,
        checkbox: 0,
        label: 0,
        canvas: 0,
        image: 0,
        dropsurface: 0,
        dropdown: 0,
        list: 0,
        progressbar: 0,
        meter: 0,
        gswitch: 0,
        container: 0,
        tabs: 0,
        plot: 0,
        radiobuttongroup: 0,
    };

    allWidgets.forEach((widget) => {
        const type =
            widget.dataset.type.toLowerCase() === "input"
                ? "textbox"
                : widget.dataset.type.toLowerCase();
        if (widgetCounts.hasOwnProperty(type)) {
            widgetCounts[type]++;
        }
    });

    cCode += `    /* Allocate widget arrays */\n`;
    Object.entries(widgetCounts).forEach(([type, count]) => {
        if (count > 0) {
            const varName = type == "tabs" ? `${type}` : `${type}s`;
            const countName = `${type}_count`;
            const widgetTypeName = getWidgetTypeName(type);
            cCode += `    state.${varName} = (${widgetTypeName} **)malloc(sizeof(${widgetTypeName}*) * ${count}U);
    if (state.${varName} == NULL)
    {
`;
            if (state.projectSettings.platform === "embedded") {
                cCode += `        return;
    }
`;
            } else {
                cCode += `        return -1;
    }
`;
            }
            cCode += `    state.${countName} = ${count}U;\n\n`;
        }
    });

    cCode += `    /* Initialize GooeyGUI framework */
    Gooey_Init();

`;

    const winTitle = document
        .getElementById("win-title")
        .value.replace(/"/g, '\\"');
    const winWidth = document.getElementById("win-width").value;
    const winHeight = document.getElementById("win-height").value;

    cCode += `    /* Create main application window */
    state.window = GooeyWindow_Create("${winTitle}", 0, 0, ${winWidth}, ${winHeight}, true);
    if (state.window == NULL)
    {
`;
    if (state.projectSettings.platform === "embedded") {
        cCode += `        return;
    }

`;
    } else {
        cCode += `        return -1;
    }

`;
    }

    if (state.previewWindow.dataset.debug_overlay === "true")
        cCode += `    GooeyWindow_EnableDebugOverlay(state.window, true);\n`;

    if (state.previewWindow.dataset.cont_redraw === "true")
        cCode += `    GooeyWindow_SetContinuousRedraw(state.window);\n`;

    if (state.previewWindow.dataset.is_visible === "true")
        cCode += `    GooeyWindow_MakeVisible(state.window, true);\n`;
    else cCode += `    GooeyWindow_MakeVisible(state.window, false);\n`;

    if (state.previewWindow.dataset.is_resizable === "true")
        cCode += `    GooeyWindow_MakeResizable(state.window, true);\n`;
    else cCode += `    GooeyWindow_MakeResizable(state.window, false);\n\n`;

    const widgetIndices = {
        button: 0,
        textbox: 0,
        slider: 0,
        checkbox: 0,
        label: 0,
        canvas: 0,
        image: 0,
        dropsurface: 0,
        dropdown: 0,
        list: 0,
        progressbar: 0,
        meter: 0,
        gswitch: 0,
        container: 0,
        tabs: 0,
        plot: 0,
        radiobuttongroup: 0,
    };

    state.widgetCounter = 0;
    const widgetVars = new Set();
    const widgetRegistrations = [];
    const processedWidgetIds = new Set();

    function generateUniqueVarName(baseName) {
        let counter = 1;
        let varName = baseName;

        while (widgetVars.has(varName)) {
            varName = `${baseName}_${counter++}`;
        }

        widgetVars.add(varName);
        return varName;
    }

    function processWidgetC(
        widget,
        indent,
        parentVar = null,
        containerId = null,
        tabId = null,
    ) {
        const widgetId = widget.dataset.id;

        if (processedWidgetIds.has(widgetId)) {
            return "";
        }

        processedWidgetIds.add(widgetId);

        const type = widget.dataset.type;
        let x = parseInt(widget.style.left) || 0;
        let y = parseInt(widget.style.top) || 0;
        const width = parseInt(widget.style.width) || 100;
        const height = parseInt(widget.style.height) || 30;

        let text = widget.textContent || "";
        text = text.replace(/"/g, '\\"');

        const callbackData = state.widgetCallbacks[widgetId];
        const callbackName = callbackData?.callbackName || "";
        const macroName = state.widgetMacroNames.get(widgetId);

        let callbackWithData = "NULL, NULL";
        if (callbackName) {
            callbackWithData = `${callbackName}_wrapper, (void*)&state`;
        }

        let widgetVar = widget.dataset.widgetVar;
        if (!widgetVar || widgetVars.has(widgetVar)) {
            widgetVar = generateUniqueVarName(
                `${type.toLowerCase()}_${state.widgetCounter++}`,
            );
            widget.dataset.widgetVar = widgetVar;
        } else {
            widgetVars.add(widgetVar);
        }

        let widgetCode = "";
        const typeLower = type.toLowerCase();
        const macroComment = macroName ? ` (macro: ${macroName})` : "";

        switch (type) {
            case "Button":
                widgetCode += `${indent}/* Create button${macroComment} */
${indent}GooeyButton* ${widgetVar} = GooeyButton_Create("${text}", ${x}, ${y}, ${width}, ${height}, ${callbackWithData});
${indent}state.buttons[${widgetIndices.button++}] = ${widgetVar};
`;
                break;

            case "Input":
                widgetCode += `${indent}/* Create textbox${macroComment} */
${indent}GooeyTextbox* ${widgetVar} = GooeyTextBox_Create(${x}, ${y}, ${width}, ${height}, "${text}", false, ${callbackWithData});
${indent}state.textboxs[${widgetIndices.textbox++}] = ${widgetVar};
`;
                break;

            case "Slider":
                const minValue = widget.dataset.minValue || 0;
                const maxValue = widget.dataset.maxValue || 100;
                const showHints = widget.dataset.showHints || "false";
                widgetCode += `${indent}/* Create slider${macroComment} */
${indent}GooeySlider* ${widgetVar} = GooeySlider_Create(${x}, ${y}, ${width}, ${minValue}, ${maxValue}, ${showHints}, ${callbackWithData});
${indent}state.sliders[${widgetIndices.slider++}] = ${widgetVar};
`;
                break;

            case "Checkbox":
                widgetCode += `${indent}/* Create checkbox${macroComment} */
${indent}GooeyCheckbox* ${widgetVar} = GooeyCheckbox_Create(${x}, ${y}, "${text}", ${callbackWithData});
${indent}state.checkboxes[${widgetIndices.checkbox++}] = ${widgetVar};
`;
                break;

            case "Label":
                widgetCode += `${indent}/* Create label${macroComment} */
${indent}GooeyLabel* ${widgetVar} = GooeyLabel_Create("${text}", 18.0f, ${x}, ${y});
${indent}state.labels[${widgetIndices.label++}] = ${widgetVar};
`;
                break;

            case "Canvas":
                widgetCode += `${indent}/* Create canvas${macroComment} */
${indent}GooeyCanvas* ${widgetVar} = GooeyCanvas_Create(${x}, ${y}, ${width}, ${height}, NULL, NULL);
${indent}state.canvases[${widgetIndices.canvas++}] = ${widgetVar};
`;
                break;

            case "Image":
                const imagePath =
                    widget.dataset.relativePath || "./assets/example.png";
                widgetCode += `${indent}/* Create image${macroComment} */
${indent}GooeyImage* ${widgetVar} = GooeyImage_Create("${imagePath}", ${x}, ${y}, ${width}, ${height}, ${callbackWithData});
${indent}state.images[${widgetIndices.image++}] = ${widgetVar};
`;
                break;

            case "DropSurface":
                const message =
                    widget.dataset.dropsurfaceMessage || "Drop files here..";
                widgetCode += `${indent}/* Create drop surface${macroComment} */
${indent}GooeyDropSurface* ${widgetVar} = GooeyDropSurface_Create(${x}, ${y}, ${width}, ${height}, "${message}", ${callbackWithData});
${indent}state.dropsurfaces[${widgetIndices.dropsurface++}] = ${widgetVar};
`;
                break;

            case "Dropdown":
                const dropdownOptionsList = widget.dataset.dropdownOptions
                    ? widget.dataset.dropdownOptions.split(",")
                    : [];
                const dropdownOptionsListLength = dropdownOptionsList.length;
                const formattedOptions = dropdownOptionsList.map(
                    (o) => `"${o.trim()}"`,
                );

                widgetCode += `${indent}/* Create dropdown${macroComment} */
`;
                if (dropdownOptionsListLength > 0) {
                    widgetCode += `${indent}const char* options_${widgetVar}[${dropdownOptionsListLength}] = {${formattedOptions.join(", ")}};
${indent}GooeyDropdown* ${widgetVar} = GooeyDropdown_Create(${x}, ${y}, ${width}, ${height}, options_${widgetVar}, ${dropdownOptionsListLength}, ${callbackWithData});
`;
                } else {
                    widgetCode += `${indent}GooeyDropdown* ${widgetVar} = GooeyDropdown_Create(${x}, ${y}, ${width}, ${height}, NULL, 0, ${callbackWithData});
`;
                }
                widgetCode += `${indent}state.dropdowns[${widgetIndices.dropdown++}] = ${widgetVar};
`;
                break;

            case "List":
                const listOptionsList = widget.dataset.listOptions
                    ? JSON.parse(widget.dataset.listOptions)
                    : [];
                widgetCode += `${indent}/* Create list${macroComment} */
${indent}GooeyList* ${widgetVar} = GooeyList_Create(${x}, ${y}, ${width}, ${height}, ${callbackWithData});
${indent}state.lists[${widgetIndices.list++}] = ${widgetVar};
`;

                listOptionsList.forEach((item) => {
                    widgetCode += `${indent}GooeyList_AddItem(${widgetVar}, "${item.name || ""}", "${item.description || ""}");
`;
                });
                break;

            case "Menu":
                widgetCode += `${indent}/* Create menu${macroComment} */
${indent}GooeyMenu* ${widgetVar} = GooeyMenu_Set(state.window);
${indent}state.menu = ${widgetVar};
`;
                break;

            case "RadioButtonGroup":
                widgetCode += `${indent}/* Create radio button group${macroComment} */
${indent}GooeyRadioButtonGroup* ${widgetVar} = GooeyRadioButtonGroup_Create();
${indent}state.radiobuttongroups[${widgetIndices.radiobuttongroup++}] = ${widgetVar};
`;
                // Remove [ and ] from the start and end, then split by comma
                const rawString = widget.dataset.radioOptions.replace(
                    /^\[|\]$/g,
                    "",
                );
                const radioOptions = rawString.split(",");

                for (let i = 0; i < radioOptions.length; i++) {
                    // Remove leading/trailing quotes if they exist
                    let label = radioOptions[i]
                        .trim()
                        .replace(/^["']|["']$/g, "");

                    y = (y || 0) + i * 10;

                    // Wrap label in quotes for the C code
                    widgetCode += `${indent}GooeyRadioButtonGroup_AddChild(state.window, ${widgetVar}, ${x}, ${y}, "${label}", ${widget.dataset.callback || "NULL"}, ${widget.dataset.user_data || "NULL"});\n`;
                }
                break;

            case "Progressbar":
                const progressValue = widget.dataset.value || 50;
                widgetCode += `${indent}/* Create progressbar${macroComment} */
${indent}GooeyProgressBar* ${widgetVar} = GooeyProgressBar_Create(${x}, ${y}, ${width}, ${height}, ${progressValue});
${indent}state.progressbars[${widgetIndices.progressbar++}] = ${widgetVar};
`;
                break;

            case "Meter":
                const meterValue = widget.dataset.value || 50;
                const meterLabel = widget.dataset.label || "Meter";
                widgetCode += `${indent}/* Create meter${macroComment} */
${indent}GooeyMeter* ${widgetVar} = GooeyMeter_Create(${x}, ${y}, ${width}, ${height}, ${meterValue}, "${meterLabel}", NULL);
${indent}state.meters[${widgetIndices.meter++}] = ${widgetVar};
`;
                break;

            case "GSwitch":
                const isToggled = widget.classList.contains("checked")
                    ? "true"
                    : "false";
                const showSwitchHints = widget.dataset.showHints || "false";
                widgetCode += `${indent}/* Create switch${macroComment} */
${indent}GooeySwitch* ${widgetVar} = GooeySwitch_Create(${x}, ${y}, ${isToggled}, ${showSwitchHints}, ${callbackWithData});
${indent}state.gswitchs[${widgetIndices.gswitch++}] = ${widgetVar};
`;
                break;

            case "Container":
                widgetCode += `${indent}/* Create container${macroComment} */
${indent}GooeyContainer* ${widgetVar} = GooeyContainer_Create(${x}, ${y}, ${width}, ${height});
${indent}state.containers[${widgetIndices.container++}] = ${widgetVar};
`;

                const containerNames = JSON.parse(
                    widget.dataset.containerNames || '["Container 0"]',
                );

                containerNames.forEach((name, index) => {
                    widgetCode += `${indent}GooeyContainer_InsertContainer(${widgetVar}); /* ${name} */
`;
                });

                const activeContainer = parseInt(
                    widget.dataset.activeContainer || "0",
                );
                widgetCode += `${indent}GooeyContainer_SetActiveContainer(${widgetVar}, ${activeContainer});
`;

                containerNames.forEach((name, index) => {
                    const containerWidgets = getWidgetsInContainer(
                        widget,
                        index,
                    );
                    containerWidgets.forEach((childData) => {
                        const childCode = processWidgetC(
                            childData.widget,
                            indent + "    ",
                            widgetVar,
                            index,
                            null,
                        );
                        widgetCode += childCode;
                        widgetCode += `${indent}GooeyContainer_AddWidget(state.window, ${widgetVar}, ${index}, ${childData.widget.dataset.widgetVar});
`;
                    });
                });
                break;

            case "Tabs":
                widgetCode += `${indent}/* Create tabs${macroComment} */
${indent}const bool isSidebar = ${widget.dataset.isSidebar || "false"};
${indent}GooeyTabs* ${widgetVar} = GooeyTabs_Create(${x}, ${y}, ${width}, ${height}, isSidebar);
${indent}state.tabs[${widgetIndices.tabs++}] = ${widgetVar};
`;

                const tabNames = JSON.parse(
                    widget.dataset.tabNames || '["Tab 1", "Tab 2"]',
                );

                tabNames.forEach((name, index) => {
                    widgetCode += `${indent}GooeyTabs_InsertTab(${widgetVar}, "${name}");
`;
                });

                const activeTab = parseInt(widget.dataset.activeTab || "0");
                widgetCode += `${indent}GooeyTabs_SetActiveTab(${widgetVar}, ${activeTab});
`;

                tabNames.forEach((name, index) => {
                    const tabWidgets = getWidgetsInTab(widget, index);
                    tabWidgets.forEach((childData) => {
                        const childCode = processWidgetC(
                            childData.widget,
                            indent + "    ",
                            widgetVar,
                            null,
                            index,
                        );
                        widgetCode += childCode;
                        widgetCode += `${indent}GooeyTabs_AddWidget(state.window, ${widgetVar}, ${index}, ${childData.widget.dataset.widgetVar});
`;
                    });
                });
                break;

            case "Plot":
                widgetCode += `${indent}/* Create plot${macroComment} */
${indent}float x_data_${widgetVar}[]  = {${widget.dataset.xAxisDataList || "1.0f, 2.0f, 3.0f"}};
${indent}float y_data_${widgetVar}[]  = {${widget.dataset.yAxisDataList || "1.0f, 2.0f, 3.0f"}};
`;

                let selectedType;
                switch (widget.dataset.plotType) {
                    case "scatter":
                        selectedType = "GOOEY_PLOT_SCATTER";
                        break;
                    case "bar":
                        selectedType = "GOOEY_PLOT_BAR";
                        break;
                    case "pie":
                        selectedType = "GOOEY_PLOT_PIE";
                        break;
                    default:
                        selectedType = "GOOEY_PLOT_LINE";
                        break;
                }

                widgetCode += `${indent}GooeyPlotData* plotData_${widgetVar} = malloc(sizeof(GooeyPlotData));
${indent}*plotData_${widgetVar} = (GooeyPlotData) {
${indent}    .x_data = x_data_${widgetVar},
${indent}    .y_data = y_data_${widgetVar},
${indent}    .data_count = ${widget.dataset.xAxisDataList ? widget.dataset.xAxisDataList.split(",").length : 3},
${indent}    .x_label = "${widget.dataset.xAxisLabel || "X-Axis Label"}",
${indent}    .x_step = 1.0f,
${indent}    .y_label = "${widget.dataset.yAxisLabel || "Y-Axis Label"}",
${indent}    .y_step = 1.0f,
${indent}    .title = "${widget.dataset.plotTitle || "Plot Title"}",
${indent}    .plot_type = ${selectedType}
${indent}};
${indent}GooeyPlot* ${widgetVar} = GooeyPlot_Create(${selectedType}, plotData_${widgetVar}, ${x}, ${y}, ${width}, ${height});
${indent}state.plots[${widgetIndices.plot++}] = ${widgetVar};
`;
                break;
        }

        if (type !== "Menu" && !parentVar) {
            widgetRegistrations.push(
                `${indent}GooeyWindow_RegisterWidget(state.window, ${widgetVar});\n`,
            );
        }

        return widgetCode;
    }

    const containerTabWidgets = allWidgets.filter((widget) => {
        const type = widget.dataset.type;
        return type === "Container" || type === "Tabs";
    });

    containerTabWidgets.forEach((widget) => {
        cCode += processWidgetC(widget, "    ");
    });

    allWidgets.forEach((widget) => {
        const widgetId = widget.dataset.id;

        if (processedWidgetIds.has(widgetId)) return;

        const type = widget.dataset.type;
        if (type === "Container" || type === "Tabs") return;

        const hierarchy = state.widgetHierarchy.get(widgetId);
        if (!hierarchy || (!hierarchy.containerId && !hierarchy.tabId)) {
            cCode += processWidgetC(widget, "    ");
        }
    });

    if (widgetRegistrations.length > 0) {
        cCode += `\n    /* Register widgets with window */\n`;
        widgetRegistrations.forEach((reg) => (cCode += reg));
    }

    cCode += `
    /* Run main application loop */
    GooeyWindow_Run(1, state.window);

    /* Cleanup resources */
    GooeyWindow_Cleanup(1, state.window);
`;

    Object.entries(widgetCounts).forEach(([type, count]) => {
        if (count > 0) {
            if (type == "tabs")
                cCode += `    free(state.${type});
    state.${type} = NULL;
`;
            else
                cCode += `    free(state.${type}s);
    state.${type}s = NULL;
`;
        }
    });

    if (state.projectSettings.platform === "embedded") {
        cCode += `}

void loop(void)
{
    /* Empty for now */
}
`;
    } else {
        cCode += `    return 0;
}
`;
    }

    state.editor.setValue(cCode);

    document.getElementById("status-text").textContent = "Code generated";
    setTimeout(() => {
        document.getElementById("status-text").textContent = "Ready";
    }, 2000);

    return cCode;
}

function getWidgetTypeName(type) {
    const typeMap = {
        button: "GooeyButton",
        textbox: "GooeyTextbox",
        slider: "GooeySlider",
        checkbox: "GooeyCheckbox",
        label: "GooeyLabel",
        canvas: "GooeyCanvas",
        image: "GooeyImage",
        dropsurface: "GooeyDropSurface",
        dropdown: "GooeyDropdown",
        list: "GooeyList",
        progressbar: "GooeyProgressBar",
        meter: "GooeyMeter",
        gswitch: "GooeySwitch",
        container: "GooeyContainer",
        tabs: "GooeyTabs",
        plot: "GooeyPlot",
        radiobuttongroup: "GooeyRadioButtonGroup",
    };

    return (
        typeMap[type] || `Gooey${type.charAt(0).toUpperCase() + type.slice(1)}`
    );
}
